#include "./graphics/api/gles/geometry_gfx_impl.h"

#include "./graphics/api/gles/gpu_buffer.h"

namespace Splash::gfx::gles
{

/*************/
GeometryGfxImpl::GeometryGfxImpl()
{
    glGenQueries(1, &_feedbackQuery);
}

/*************/
GeometryGfxImpl::~GeometryGfxImpl()
{
    for (auto v : _vertexArray)
        glDeleteVertexArrays(1, &(v.second));

    glDeleteQueries(1, &_feedbackQuery);
}

/*************/
void GeometryGfxImpl::activate()
{
    const auto currentGlfwContext = glfwGetCurrentContext();
    if (const auto vaoIt = _vertexArray.find(currentGlfwContext); vaoIt != _vertexArray.end())
        glBindVertexArray(vaoIt->second);
}

/*************/
void GeometryGfxImpl::deactivate()
{
    if (_activatedAsSharedBuffers)
    {
        glMemoryBarrier(GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT);
        _activatedAsSharedBuffers = false;
    }

#if DEBUG
    glBindVertexArray(0);
#endif
}

/*************/
void GeometryGfxImpl::activateAsSharedBuffer()
{
    const auto& buffers = _useAlternativeBuffers ? _glAlternativeBuffers : _glBuffers;

    for (uint32_t i = 0; i < buffers.size(); i++)
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, i, buffers[i]->getId());

    _activatedAsSharedBuffers = true;
}

/*************/
void GeometryGfxImpl::resizeTempBuffers()
{
    _temporaryBufferSize = _feedbackMaxNbrPrimitives * 6; // 3 vertices per primitive, times two to keep some margin for future updates
    for (size_t i = 0; i < _glBuffers.size(); ++i)
    {
        auto tempBuffer = std::make_shared<GpuBuffer>(*_glBuffers[i]);
        tempBuffer->resize(_temporaryBufferSize);
        _glTemporaryBuffers[i] = tempBuffer;
    }
}

/*************/
void GeometryGfxImpl::activateForFeedback()
{
    for (unsigned int i = 0; i < _glTemporaryBuffers.size(); ++i)
    {
        _glTemporaryBuffers[i]->clear();
        glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, i, _glTemporaryBuffers[i]->getId());
    }

    glBeginQuery(GL_PRIMITIVES_GENERATED, _feedbackQuery);
    _activatedForFeedback = true;
}

/*************/
void GeometryGfxImpl::deactivateFeedback()
{
#if DEBUG
    for (unsigned int i = 0; i < _glTemporaryBuffers.size(); ++i)
        glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, i, 0);
#endif

    glEndQuery(GL_PRIMITIVES_GENERATED);
    GLuint drawnPrimitives = 0;
    while (true)
    {
        glGetQueryObjectuiv(_feedbackQuery, GL_QUERY_RESULT_AVAILABLE, &drawnPrimitives);
        if (drawnPrimitives != 0)
            break;
        std::this_thread::sleep_for(std::chrono::microseconds(500));
    }

    glGetQueryObjectuiv(_feedbackQuery, GL_QUERY_RESULT, &drawnPrimitives);
    _feedbackMaxNbrPrimitives = std::max(_feedbackMaxNbrPrimitives, drawnPrimitives);
    _temporaryVerticesNumber = drawnPrimitives * 3;

    glMemoryBarrier(GL_TRANSFORM_FEEDBACK_BARRIER_BIT);
    _activatedForFeedback = false;
}

/*************/
void GeometryGfxImpl::draw() const
{
    if (_activatedForFeedback)
        glDrawArrays(GL_PATCHES, 0, getVerticesNumber());
    else
        glDrawArrays(GL_TRIANGLES, 0, getVerticesNumber());
}

/*************/
uint32_t GeometryGfxImpl::getVerticesNumber() const
{
    return _useAlternativeBuffers ? _alternativeVerticesNumber : _verticesNumber;
}

/*************/
bool GeometryGfxImpl::buffersTooSmall()
{
    // Feedback buffers hold primitives, which are triangles. Hence the maximum number of primitives
    // is compared to a third of the number of vertices (discarding the fact that some vertices
    // can be used more than once).
    // If the computed value is greater than the current _temporarybufferSize, which holds 3 vertex
    // for each primitive, then the buffers are too small to hold all of the geometry generated by
    // the transform feedback (and should resized accordingly).
    _feedbackMaxNbrPrimitives = std::max(_verticesNumber / 3, _feedbackMaxNbrPrimitives);
    return _feedbackMaxNbrPrimitives * 3 > _temporaryBufferSize;
}

/*************/
std::vector<char> GeometryGfxImpl::getGpuBufferAsVector(int typeId, bool forceAlternativeBuffers = false)
{
    if ((forceAlternativeBuffers || _useAlternativeBuffers) && _glAlternativeBuffers[typeId] != nullptr)
        return _glAlternativeBuffers[typeId]->getBufferAsVector();
    else
        return _glBuffers[typeId]->getBufferAsVector();
}

/*************/
bool GeometryGfxImpl::anyAlternativeBufferMissing() const
{
    return std::any_of(_glAlternativeBuffers.cbegin(), _glAlternativeBuffers.cend(), [](const auto& buffer) { return buffer == nullptr; });
}

/*************/
Mesh::MeshContainer GeometryGfxImpl::serialize(const std::string& name)
{
    if (anyAlternativeBufferMissing())
        return {};

    const auto vertices = _glAlternativeBuffers[0]->getBufferAsVector();
    const auto uvs = _glAlternativeBuffers[1]->getBufferAsVector();
    const auto normals = _glAlternativeBuffers[2]->getBufferAsVector();
    const auto annexe = _glAlternativeBuffers[3]->getBufferAsVector();

    const auto verticesData = reinterpret_cast<const glm::vec4*>(vertices.data());
    const auto uvsData = reinterpret_cast<const glm::vec2*>(uvs.data());
    const auto normalsData = reinterpret_cast<const glm::vec4*>(normals.data());
    const auto annexeData = reinterpret_cast<const glm::vec4*>(annexe.data());

    return Mesh::MeshContainer{
        .name = name,
        .vertices = std::vector<glm::vec4>(verticesData, verticesData + _alternativeVerticesNumber),
        .uvs = std::vector<glm::vec2>(uvsData, uvsData + _alternativeVerticesNumber),
        .normals = std::vector<glm::vec4>(normalsData, normalsData + _alternativeVerticesNumber),
        .annexe = std::vector<glm::vec4>(annexeData, annexeData + _alternativeVerticesNumber),
    };
}

/*************/
void GeometryGfxImpl::swapBuffers()
{
    _glAlternativeBuffers.swap(_glTemporaryBuffers);

    int tmp = _alternativeVerticesNumber;
    _alternativeVerticesNumber = _temporaryVerticesNumber;
    _temporaryVerticesNumber = tmp;

    tmp = _alternativeBufferSize;
    _alternativeBufferSize = _temporaryBufferSize;
    _temporaryBufferSize = tmp;
}

/*************/
void GeometryGfxImpl::initVertices(float* data, uint32_t numVerts)
{
    setVerticesNumber(numVerts);
    _glBuffers[0] = std::make_shared<GpuBuffer>(4, GL_FLOAT, GL_STATIC_DRAW, _verticesNumber, data);
}

/*************/
void GeometryGfxImpl::allocateOrInitBuffer(uint32_t bufferIndex, uint32_t componentsPerElement, std::vector<float>& dataVec)
{
    if (!dataVec.empty())
        _glBuffers[bufferIndex] = std::make_shared<GpuBuffer>(componentsPerElement, GL_FLOAT, GL_STATIC_DRAW, _verticesNumber, dataVec.data());
    else
        _glBuffers[bufferIndex] = std::make_shared<GpuBuffer>(componentsPerElement, GL_FLOAT, GL_STATIC_DRAW, _verticesNumber, nullptr);
}

/*************/
void GeometryGfxImpl::clearFromAllContexts()
{
    for (auto& v : _vertexArray)
        glDeleteVertexArrays(1, &(v.second));

    _vertexArray.clear();
}

/*************/
void GeometryGfxImpl::updateTemporaryBuffers(Mesh::MeshContainer* deserializedMesh)
{
    _temporaryVerticesNumber = deserializedMesh->vertices.size();
    _temporaryBufferSize = _temporaryVerticesNumber;

    allocateOrInitTemporaryBuffer(0, 4, _temporaryVerticesNumber, reinterpret_cast<char*>(deserializedMesh->vertices.data()));
    allocateOrInitTemporaryBuffer(1, 2, _temporaryVerticesNumber, reinterpret_cast<char*>(deserializedMesh->uvs.data()));
    allocateOrInitTemporaryBuffer(2, 4, _temporaryVerticesNumber, reinterpret_cast<char*>(deserializedMesh->normals.data()));
    allocateOrInitTemporaryBuffer(3, 4, _temporaryVerticesNumber, reinterpret_cast<char*>(deserializedMesh->annexe.data()));
}

/*************/
void GeometryGfxImpl::update(bool buffersDirty)
{
    GLFWwindow* context = glfwGetCurrentContext();
    auto vertexArrayIt = _vertexArray.find(context);
    if (vertexArrayIt == _vertexArray.end() || buffersDirty)
    {
        if (vertexArrayIt == _vertexArray.end())
        {
            vertexArrayIt = (_vertexArray.emplace(std::make_pair(context, 0))).first;
            vertexArrayIt->second = 0;
            glGenVertexArrays(1, &(vertexArrayIt->second));
        }

        glBindVertexArray(vertexArrayIt->second);

        for (uint32_t idx = 0; idx < _glBuffers.size(); ++idx)
        {

            const auto& buffers = (_useAlternativeBuffers && _glAlternativeBuffers[0] != nullptr) ? _glAlternativeBuffers : _glBuffers;

            glBindBuffer(GL_ARRAY_BUFFER, buffers[idx]->getId());
            glVertexAttribPointer((GLuint)idx, buffers[idx]->getElementSize(), GL_FLOAT, GL_FALSE, 0, 0);
            glEnableVertexAttribArray((GLuint)idx);
        }

        glBindBuffer(GL_ARRAY_BUFFER, 0);
        glBindVertexArray(0);
    }
}

/*************/
void GeometryGfxImpl::useAlternativeBuffers(bool isActive)
{
    _useAlternativeBuffers = isActive;
}

/*************/
void GeometryGfxImpl::setVerticesNumber(uint32_t verticesNumber)
{
    _verticesNumber = verticesNumber;
}

/*************/
void GeometryGfxImpl::allocateOrInitTemporaryBuffer(uint32_t bufferIndex, uint32_t componentsPerElement, uint32_t tempVerticesNumber, char* data)
{
    if (!_glTemporaryBuffers[bufferIndex])
        _glTemporaryBuffers[bufferIndex] = std::make_shared<GpuBuffer>(componentsPerElement, GL_FLOAT, GL_STATIC_DRAW, tempVerticesNumber, reinterpret_cast<GLvoid*>(data));
    else
        _glTemporaryBuffers[bufferIndex]->setBufferFromVector({data, data + tempVerticesNumber * sizeof(float) * componentsPerElement});
}

} // namespace Splash::gfx::gles
